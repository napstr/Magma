buildscript {
    ext {
        grgitVersion = '3.1.1'
        sonarqubeVersion = '2.7'
        versionsVersion = '0.21.0'
        bintrayVersion = '1.8.4'
    }
    repositories {
        maven { url 'https://plugins.gradle.org/m2/' }
        mavenCentral()
    }
    dependencies {
        classpath "org.ajoberstar.grgit:grgit-gradle:${grgitVersion}"
        classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:${sonarqubeVersion}"
        classpath "com.github.ben-manes:gradle-versions-plugin:${versionsVersion}"
        classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:${bintrayVersion}"
    }
}

ext {
    //@formatter:off
    orgJsonVersion              = '20190722'
    slf4jVersion                = '1.7.28'

    springVersion               = '5.1.9.RELEASE'
    undertowVersion             = '2.0.25.Final'
    xnioVersion                 = '3.3.8.Final'
    reactorVersion              = '3.2.11.RELEASE'

    spotbugsVersion             = '3.1.12'
    annotationsVersion          = '0.0.1'

    immutablesVersion           = '2.7.5'

    junitVersion                = '5.5.1'
    logbackVersion              = '1.2.3'
    //@formatter:on
}

apply plugin: 'org.ajoberstar.grgit'
apply plugin: 'com.jfrog.bintray'

allprojects {
    apply plugin: 'java-library'
    apply plugin: 'maven-publish'
    apply plugin: 'jacoco'
    apply plugin: 'org.sonarqube'
    apply plugin: 'com.github.ben-manes.versions'

    group = "space.npstr.magma"
    version = "${versionFromTag()}"
    archivesBaseName = project.name

    sourceCompatibility = targetCompatibility = JavaVersion.VERSION_1_8

    repositories {
        jcenter()
        maven { url 'https://jitpack.io' }
    }

    compileJava {
        options.encoding = 'UTF-8'
        options.incremental = true
        options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
    }

    test {
        useJUnitPlatform()
        jacoco {
            includes['space.npstr.magma.*']
        }
    }

    sonarqube {
        properties {
            property "sonar.inclusions", "**/src/main/java/space/npstr/magma/**/*.java"
        }
    }

    publishToMavenLocal.dependsOn jar
    task sourceJar(type: Jar) {
        from sourceSets.main.allJava
        archiveClassifier.set('sources')
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
        archiveClassifier = 'javadoc'
        from javadoc.destinationDir
    }

    // called by jitpack
    task install {
        dependsOn test
        dependsOn publishToMavenLocal
        doLast {
            println 'Version: ' + version
        }
    }

    defaultTasks 'build'

    publishing {
        publications {
            mavenJava(MavenPublication) {
                from components.java
                groupId project.group
                artifactId archivesBaseName
                version project.version

                artifact sourceJar
                artifact javadocJar

                pom {
                    name = 'Magma'
                    description = 'A voice only API for Discord, focused on delivering music at scale.'
                    url = 'https://github.com/napstr/Magma'
                    licenses {
                        license {
                            name = 'Apache License 2.0'
                            url = 'https://choosealicense.com/licenses/apache-2.0/'
                            distribution = 'repo'
                        }
                    }
                    developers {
                        developer {
                            name = 'Napster'
                            email = 'napster@npstr.space'
                        }
                    }
                    scm {
                        url = 'https://github.com/napstr/Magma'
                    }
                }
            }
        }
    }

    bintray {
        user = this.properties["bintrayUsername"]
        key = this.properties["bintrayApiKey"]
        publications = ["mavenJava"]
        pkg {
            repo = "maven"
            name = archivesBaseName
            licenses = ["Apache-2.0"]
            vcsUrl = "https://github.com/MinnDevelopment/Magma"
            githubRepo = "MinnDevelopment/Magma"
            publish = true
            version {
                name = project.version
                vcsTag = project.version
                released = new Date()
                gpg.sign = true
            }
        }
    }

    bintrayUpload {
        dependsOn clean
        dependsOn build
        dependsOn javadocJar
        dependsOn sourceJar
        build.mustRunAfter clean
    }

    dependencyUpdates.resolutionStrategy {
        componentSelection { rules ->
            rules.all { ComponentSelection selection ->
                boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm', 'preview', 'b', 'ea'].any { qualifier ->
                    selection.candidate.version ==~ /(?i).*[.-]$qualifier[.\d-+]*/
                }
                if (rejected) {
                    selection.reject('Release candidate')
                }
            }
        }
    }

    dependencies {
        // annotations
        compileOnly "com.github.spotbugs:spotbugs-annotations:$spotbugsVersion"
        compileOnly "space.npstr:annotations:$annotationsVersion"

        // immutable objects, to pass values around
        compileOnly "org.immutables:value:$immutablesVersion:annotations"
        annotationProcessor "org.immutables:value:$immutablesVersion"

        //testing
        testImplementation "org.junit.jupiter:junit-jupiter-api:$junitVersion"
        testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:$junitVersion"
        testRuntimeOnly "ch.qos.logback:logback-classic:$logbackVersion"
    }
}

apply plugin: 'java-library'
dependencies {
    api project(':api')
    implementation project(':impl')
}

project(':api') {
    apply plugin: 'java-library'
    dependencies {
        api "org.slf4j:slf4j-api:$slf4jVersion"

        // project reactor & reactive websocket client
        api "org.springframework:spring-webflux:$springVersion"
        api "io.undertow:undertow-core:$undertowVersion"
        api "org.jboss.xnio:xnio-nio:$xnioVersion"
        api "io.projectreactor:reactor-core:$reactorVersion"
    }
}

project(':impl') {
    dependencies {
        implementation project(':api')

        implementation "org.json:json:$orgJsonVersion"
    }
}

build {
    doLast {
        println 'Version: ' + version
    }
}


//returns either a git tag if there is one on this commit, or the commit hash, to be used as a version
@SuppressWarnings("GrMethodMayBeStatic")
String versionFromTag() {
    def headTag = grgit.tag.list().find {
        it.commit == grgit.head()
    }

    def clean = grgit.status().clean //uncommited changes? -> should be SNAPSHOT

    if (headTag && clean) {
        headTag.getName()
    } else {
        "${grgit.head().id}-SNAPSHOT"
    }
}
